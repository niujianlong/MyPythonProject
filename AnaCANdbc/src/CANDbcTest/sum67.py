#coding:gbk 
nums=[1, 2, 2, 6, 99, 99, 7,6,6,6,6,7,8,9,7,]  
def sum67(nums):
    s=0
    
    while 6 in nums and 7 in nums: #如果数组中存在6并且7 开始进行下边的while代码 下边会删除6到7之间的数组元素，然后再返回来判断这个条件是不是
        #还成立，如果成立下边的while里继续删除，知道这个数组里不同时存在6和7这2个元素则会退出这个while循环
        n6 = nums.index(6) #n6记录6在数组中第一次出现的位置的索引
        n7 = nums.index(7) #n7记录7在数组中第一次出现的位置的索引
        if n6 < n7:  #如果6出现在了7的左边 就删除6到7的这个区间的数组元素
            del nums[n6:n7+1]
        elif n7 < n6:#如果6出现在了7的右边，那么先删除7，但是你删除了7势必会影响到数组的和，所以下边对数组的和先进行了加7 可以说这个elif
            #是这个小算法的精华之处，处理的非常巧妙。
            del nums[n7]
            s += 7
    for i in nums: s +=i #这个for循环再while的外边 经历了上边while循环过滤后的数组已经是不会同时存在6，7 即使存在7也在6的左边
    return s
print(sum67(nums)) 
'''
print(sum67([1,2,3,4]))
print(sum67([1,2,6,4,7,3,4]))
print(sum67([]))
print(sum67([1,2,3,8,6,3,6,7,9,6,7]))
print('==========')
print(sum67([1, 2, 2]))# 5
print(sum67([1, 2, 2, 6, 99, 99, 7]))#  5
print(sum67([1, 1, 6, 7, 2]))#  4
print(sum67([1,6,2,2,7,1,6,99,99,7]))#  2
print(sum67([1,6,2,6,2,7,1,6,99,99,7]))#  2
print(sum67([2,7,6,2,6,7,2,7]))#  18
print(sum67([2,7,6,2,6,2,7]))#  9
print(sum67([1,6,7,7]))#  8
print(sum67([6,7,1,6,7,7]))#  8
print(sum67([6,8,1,6,7]))#  0
print(sum67([]))#  0
print(sum67([6,7,11]))#  11
print(sum67([11,6,7,11]))#  22
print(sum67([2,2,6,7,7]))#  11 
'''